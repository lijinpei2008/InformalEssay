#### 迭代器：

**推导表达式：**
可以快速生产有规律的类型
**列表变量 = 【i for i in range（多少，到多少）if 判断条件】**  ---列表推导式，**注：**每次拿出多少放到i（第二个i）中 把i（第一个i）放到列表里然后赋值给列表变量，可以不加if判断条件直接把多少到多少数加入列表，加入if判断可以判断i的条件去加入列表，和三目运算一个道理，如果需要加否则（else）需要把if i的条件 else的条件放到for循环前边第一个i后边
**住1：**如果是其他类型，只在变量赋值的时候直接赋值成其他类型就可以了
**住2：**如果是字典可以在for循环的in 后边加枚举去实现字典推倒式，但是for后边的i需要变成i，j（两个变量去接受），第一个i要变成i：j的键值对去加入

#### 迭代器和生成器：

**迭代器：**

**iterable** --可迭代对象
**iter** --转换迭代器或迭代对象点 _ _iter _ _()
**next** --下一个,在迭代器中next（迭代器）可以依次取值 去到最后会报没有下一个值的错
**_ _iter _ _(self): 和 _ _next _ _(self):** --魔术方法去实现迭代器的类定义

**生成器：**

用推倒式去实现生成器，**1，变量 = （i for i in  range（多少，到多少））** 这里列表的【】改成小括号就是生成器，前边的变量就可以说是生成器，生成器返回的是一个地址，通俗的来讲生成器就是一个迭代器，用推倒式去生产列表比用生成器去实现会费内存，如果推倒式去生成列表中值很多 会非常浪费内存，生成器不会费很多内存。
**2、**用关键字**yield**去生成（只能在函数中使用）：只要函数中用了yield，那么这个函数就可以称之为生成器
**注：**在函数中遇到yield会暂停函数以及返回yield空格后边的值等待下一个取值
**注1：**生成器不会一下子把所有内容生成出来，在我们需要用到next（）是才会去生产下一个值

#### 关键字：

**help（‘keywords’）**  --查看python所有关键字

#### 模块和包：

**import 模块名** --导入模块
**from  包 import 模块名 as 变量名**：包也可以是模块名 import后边就是一个变量或函数 导入后就可以直接调用模块中的变量或函数 如果直接用import 模块名去导入 需要用模块中的某个函数需要模块名去点函数，在模块名后边的as变量名是自己吧模块或模块中的功能重新命名。
**注：**在导入的时候在同一目录下，可以直接使用上边两个导入如果是不同的文件需要用from去导入否则需要用到sys模块吧包的绝对路径增加进去（sys.path 导入路径）

**包和包管理：**

包就是很多模块放在一个文件夹里面就是一个包。
**package** --创建包，PyCharm中新建文件夹后边有package是创建包
如果自己创建一个文件夹需要声明成包需要些一个初始化py文件 第一个文件命名为 **_ _init _ _ .py**，第一个文件中可以不写东西 只是声明这个文件夹是包
**住：**包里边的模块中需要调用别的包里边的模块需要用from 指定包名 import 模块名去导入（包括包中的模块去导入包中的子包）